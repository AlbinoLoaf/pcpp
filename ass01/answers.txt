EXERCISE 1.1

MANDATORY

1. 

Output: Count is 19125501 and should be 20000000

2. 

Output: Count is 200 and should be 200

Answer: The longer the code runs, the more likely a race condition is to occur, so it's not guarantied that it's always 200.

3. 

All three types of writing the incrementation compiles to the same form of byte code, meaning the computer understands them as exactly the same

4.

We have integrated ReetrantLock by importing: java.util.concurrent.locks.ReentrantLock;

in the increment() function, we find a critical section, because we handle shared memory. To solve this we use a lock to for fill mutual exclusion as we now control the interleavings of the threads. And after we have done the not atomic one-liner count = count + 1;, we can release the lock again. Doing this assures that we don't end in a race condition.

public void increment() {
            reentrantLock.lock();
            count = count + 1;
            reentrantLock.unlock();
        }

5.

As stated previously, the critical section is this line of code: count = count + 1;

So locking around the for loop of inside each for loop would make the for a longer code section. So being precise with finding the critical section ensures the least amount of lines of code.

CHALLENGING:

6.

7.

8.

EXERCISE 1.2

MANDATORY

1.

Running the code: gradle -PmainClass=exercises01.Printer_Exercise run


Code:

package exercises01;

class Printer {
    public void print() {
        System.out.print("-");
        try {
            Thread.sleep(50);
        } catch (InterruptedException exn) {
            Thread.currentThread().interrupt();
        }
        System.out.print("|");
    }
}

public class Printer_Exercise {
    public static void main(String[] args) {
        Printer p = new Printer();
        
        Thread t1 = new Thread(() -> {
            while (true) {
                p.print();
            }
        });

        Thread t2 = new Thread(() -> {
            while (true) {
                p.print();
            }
        });

        t1.start();
        t2.start();
    }
}

2.

Let's say that T1, prints "-", as its the first thing the print method does, then goes to sleep, while it sleeps T2 starts print, printing "-", now the output is "--".

3. 

Running the code: gradle -PmainClass=exercises01.Printer_Exercise run

Code:

package exercises01;

import java.util.concurrent.locks.ReentrantLock;

class Printer {

    ReentrantLock reentrantLock = new ReentrantLock();
    public void print() {
        reentrantLock.lock();
        System.out.print("-");
        try {
            Thread.sleep(50);
        } catch (InterruptedException exn) {
            Thread.currentThread().interrupt();
        }
        System.out.print("|");
        reentrantLock.unlock();
    }
}

public class Printer_Exercise {
    public static void main(String[] args) {
        Printer p = new Printer();

        // Thread 1
        Thread t1 = new Thread(() -> {
            while (true) {
                p.print();
            }
        });

        // Thread 2
        Thread t2 = new Thread(() -> {
            while (true) {
                p.print();
            }
        });

        t1.start();
        t2.start();
    }
}


CHALLENGING

4.


